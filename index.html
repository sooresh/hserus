<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>hserus</title>
<style>
  :root{
    --bg:#07121a;--card:#0b2230;--muted:#9fb6c7;--accent:#7be3c7;--danger:#ff6b6b;
    --text:#e6f3f6;
  }
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(#021119,#07121a);color:var(--text);padding:18px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center}
  button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#022;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .small{font-size:13px;color:var(--muted)}
  #barWrap{width:100%;max-width:1100px;margin-top:12px}
  #bar{height:10px;background:rgba(255,255,255,0.05);border-radius:8px;overflow:hidden}
  #fill{height:100%;width:0%;background:linear-gradient(90deg,#7be3c7,#2bd18a);transition:width .25s}
  .tableWrap{margin-top:14px;overflow:auto;border-radius:8px;background:var(--card);padding:8px}
  table{width:100%;border-collapse:collapse;min-width:820px}
  th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:right}
  th{background:rgba(255,255,255,0.02);cursor:pointer;color:var(--muted);font-weight:600}
  td.symbol{text-align:left;color:#7bdfff;font-weight:700}
  .green{color:#7be3c7}
  .red{color:var(--danger)}
  .placeholder{color:var(--muted)}
</style>
</head>
<body>
  <header>
    <div>
      <h1>hserus</h1>
      <div class="small">hserus</div>
    </div>
    <div class="controls">
      <button id="refreshBtn">ðŸ”„ Refresh</button>
      <div id="status" class="small">Idle</div>
    </div>
  </header>

  <div id="barWrap">
    <div id="bar"><div id="fill"></div></div>
  </div>

  <div class="tableWrap">
    <table id="resultsTable">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th data-key="closePct">Close%</th>
          <th data-key="volPct">Vol%</th>
          <th data-key="same">Same?</th>
          <th data-key="ratio">Ratio</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="5" class="placeholder">Click Refresh to start scan.</td></tr>
      </tbody>
    </table>
  </div>

<script>
/* ---------- CONFIG ---------- */
const PROXY = "https://test.suresh291283.workers.dev";  // â† replace this
const BASE = PROXY;
const MAX_SYMBOLS = 250;
const BATCH_SIZE = 5;

const EXCLUDE_TOP = new Set([
  "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","MATICUSDT",
  "AVAXUSDT","DOTUSDT","LINKUSDT","TRXUSDT","LTCUSDT","SHIBUSDT","UNIUSDT","NEARUSDT",
  "APTUSDT","SUIUSDT","ATOMUSDT","BCHUSDT","ICPUSDT","TONUSDT","FILUSDT","APEUSDT","OPUSDT","FTMUSDT"
]);

/* DOM */
const refreshBtn = document.getElementById('refreshBtn');
const statusEl = document.getElementById('status');
const tbody = document.getElementById('tbody');
const fill = document.getElementById('fill');
const resultsTable = document.getElementById('resultsTable');

/* UTILS */
const sleep = ms => new Promise(r=>setTimeout(r,ms));
function pct(a,b){ if(!isFinite(a) || !isFinite(b) || b===0) return NaN; return ((a-b)/b)*100; }
function round(v, d=2){ return isFinite(v) ? Number(v).toFixed(d) : 'â€”'; }
function candleColor(o,c){ if(c>o) return 'green'; if(c<o) return 'red'; return 'doji'; }

/* NETWORK HELPERS */
async function fetchJSON(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error("HTTP " + r.status);
  return r.json();
}

async function getPerpSymbols(){
  const [ei, tick] = await Promise.all([
    fetchJSON(`${BASE}/exchangeInfo`),
    fetchJSON(`${BASE}/ticker/24hr`)
  ]);

  const perpSet = new Set((ei.symbols || [])
    .filter(s=>s.contractType==='PERPETUAL' && s.symbol.endsWith('USDT'))
    .map(s=>s.symbol));

  const filtered = (tick || [])
    .filter(t => perpSet.has(t.symbol) && !EXCLUDE_TOP.has(t.symbol))
    .map(t => ({symbol: t.symbol, score: Math.abs(t.priceChangePercent) * t.quoteVolume}))
    .sort((a,b)=>b.score - a.score)
    .slice(0, MAX_SYMBOLS)
    .map(x => x.symbol);

  return filtered;
}

async function fetchKlines(symbol, limit=30){
  return fetchJSON(`${BASE}/klines?symbol=${symbol}&interval=1h&limit=${limit}`);
}

/* BB + Pattern Check */
function sma(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
function std(arr, mean){
  return Math.sqrt(arr.reduce((s,x)=>s+(x-mean)**2,0)/arr.length);
}

function checkPatterns(k) {
  if(k.length < 21) return {pass:false};
  const closes = k.map(r => Number(r[4]));
  const last20 = closes.slice(-20);
  const mid = sma(last20);
  const sd = std(last20, mid);
  const upper = mid + 2*sd;
  const lower = mid - 2*sd;

  const last = k.at(-1);
  const prev = k.at(-2);

  const o = +last[1], h = +last[2], l = +last[3], c = +last[4], v = +last[5];
  const po = +prev[1], pc = +prev[4], pv = +prev[5];

  if(!(v > pv * 1.5)) return {pass:false};

  // patterns...
  if(h > upper && c < upper && c > mid)
    return {pass:true, ratio:(h-upper)/(upper-c), currColor:candleColor(o,c), prevColor:candleColor(po,pc)};

  if(h > mid && c < mid && c > lower)
    return {pass:true, ratio:(h-mid)/(mid-c), currColor:candleColor(o,c), prevColor:candleColor(po,pc)};

  if(l < lower && c > lower && c < mid)
    return {pass:true, ratio:(c-lower)/(lower-l), currColor:candleColor(o,c), prevColor:candleColor(po,pc)};

  if(l < mid && c > mid && c < upper)
    return {pass:true, ratio:(c-mid)/(mid-l), currColor:candleColor(o,c), prevColor:candleColor(po,pc)};

  return {pass:false};
}

/* RENDER */
function appendRowLive(obj){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td class="symbol">${obj.symbol}</td>
    <td class="${obj.closePct>=0? 'green':'red'}">${round(obj.closePct)}%</td>
    <td>${round(obj.volPct)}%</td>
    <td>${obj.same}</td>
    <td>${isNaN(obj.ratio) ? 'â€”' : obj.ratio.toFixed(4)}</td>
  `;
  tbody.appendChild(tr);
}

/* TABLE SORT */
function parseCellValue(text){
  const cleaned = text.replace(/[%\+,]/g,'').trim();
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : text.toLowerCase();
}
function sortTable(col){
  const tbodyEl = resultsTable.tBodies[0];
  const rows = Array.from(tbodyEl.rows);
  const asc = !(resultsTable.dataset["s"+col] === "asc");
  rows.sort((a,b)=>{
    const av=parseCellValue(a.cells[col].innerText);
    const bv=parseCellValue(b.cells[col].innerText);
    if(typeof av==="number" && typeof bv==="number") return asc?av-bv:bv-av;
    return asc?String(av).localeCompare(String(bv)):String(bv).localeCompare(String(av));
  });
  rows.forEach(r=>tbodyEl.appendChild(r));
  resultsTable.dataset["s"+col] = asc?"asc":"desc";
}
Array.from(resultsTable.tHead.rows[0].cells).forEach((th,i)=> th.onclick = ()=>sortTable(i));

/* MAIN */
async function runScan(){
  try{
    refreshBtn.disabled = true;
    tbody.innerHTML = '<tr><td colspan="5" class="placeholder">Preparing...</td></tr>';
    fill.style.width = '0%';

    statusEl.textContent = 'Fetching symbols...';
    const symbols = await getPerpSymbols();

    tbody.innerHTML = '';
    let processed = 0;

    for(let i=0;i<symbols.length;i+=BATCH_SIZE){
      const batch = symbols.slice(i,i+BATCH_SIZE);
      const results = await Promise.all(batch.map(s => 
        fetchKlines(s,30).then(k=>({s,k})).catch(()=>({s,k:null}))
      ));

      for(const res of results){
        processed++;
        fill.style.width = ((processed/symbols.length)*100)+'%';
        statusEl.textContent = `Scanning ${processed}/${symbols.length}: ${res.s}`;

        if(!res.k) continue;
        const info = checkPatterns(res.k);
        if(info.pass){
          const last = res.k.at(-1);
          const prev = res.k.at(-2);
          const o = +last[1], c = +last[4], v = +last[5];
          const po = +prev[1], pc = +prev[4], pv = +prev[5];

          appendRowLive({
            symbol: res.s,
            closePct: pct(c,o),
            volPct: pct(v,pv),
            same: info.currColor===info.prevColor?"Yes":"No",
            ratio: info.ratio
          });
        }
      }
      await sleep(150);
    }

    statusEl.textContent = 'Scan complete';
    refreshBtn.disabled = false;

  }catch(e){
    statusEl.textContent = 'Error: '+e.message;
    refreshBtn.disabled = false;
  }
}

refreshBtn.onclick = runScan;
</script>
</body>
</html>
