<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>hserus</title>
<style>
  :root{
    --bg:#07121a;--card:#0b2230;--muted:#9fb6c7;--accent:#7be3c7;--danger:#ff6b6b;
    --text:#e6f3f6;
  }
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(#021119,#07121a);color:var(--text);padding:18px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center}
  button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#022;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .small{font-size:13px;color:var(--muted)}
  #barWrap{width:100%;max-width:1100px;margin-top:12px}
  #bar{height:10px;background:rgba(255,255,255,0.05);border-radius:8px;overflow:hidden}
  #fill{height:100%;width:0%;background:linear-gradient(90deg,#7be3c7,#2bd18a);transition:width .25s}
  .tableWrap{margin-top:14px;overflow:auto;border-radius:8px;background:var(--card);padding:8px}
  table{width:100%;border-collapse:collapse;min-width:820px}
  th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:right}
  th{background:rgba(255,255,255,0.02);cursor:pointer;color:var(--muted);font-weight:600}
  td.symbol{text-align:left;color:#7bdfff;font-weight:700}
  .green{color:#7be3c7}
  .red{color:var(--danger)}
  .placeholder{color:var(--muted)}
  @media(max-width:900px){th,td{padding:8px;font-size:13px}h1{font-size:16px}}
</style>
</head>
<body>
  <header>
    <div>
      <h1>hserus</h1>
      <div class="small">hserus</div>
    </div>
    <div class="controls">
      <button id="refreshBtn">ðŸ”„ Refresh</button>
      <div id="status" class="small">Idle</div>
    </div>
  </header>

  <div id="barWrap">
    <div id="bar"><div id="fill"></div></div>
  </div>

  <div class="tableWrap" aria-live="polite">
    <table id="resultsTable" role="table" aria-label="scanner results">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th data-key="closePct">Close%</th>
          <th data-key="volPct">Vol%</th>
          <th data-key="same">Same?</th>
          <th data-key="ratio">Ratio</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="5" class="placeholder">Click <strong>Refresh</strong> to start scan.</td></tr>
      </tbody>
    </table>
  </div>

<script>
/* CONFIG */
const BASE = 'https://corsproxy.io/?https://fapi.binance.com';
const MAX_SYMBOLS = 250;
const BATCH_SIZE = 5;           // requested: batches of 5 symbols
const EXCLUDE_TOP = new Set([
  "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","MATICUSDT",
  "AVAXUSDT","DOTUSDT","LINKUSDT","TRXUSDT","LTCUSDT","SHIBUSDT","UNIUSDT","NEARUSDT",
  "APTUSDT","SUIUSDT","ATOMUSDT","BCHUSDT","ICPUSDT","TONUSDT","FILUSDT","APEUSDT","OPUSDT","FTMUSDT"
]);

/* DOM */
const refreshBtn = document.getElementById('refreshBtn');
const statusEl = document.getElementById('status');
const tbody = document.getElementById('tbody');
const fill = document.getElementById('fill');
const resultsTable = document.getElementById('resultsTable');

/* UTILS */
const sleep = ms => new Promise(r=>setTimeout(r,ms));
function pct(a,b){ if(!isFinite(a) || !isFinite(b) || b===0) return NaN; return ((a-b)/b)*100; }
function round(v, d=2){ if(!isFinite(v)) return 'â€”'; return Number(v).toFixed(d); }
function candleColor(o,c){ if(c>o) return 'green'; if(c<o) return 'red'; return 'doji'; }

/* NETWORK HELPERS */
async function fetchJSON(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error(url + ' -> ' + r.status);
  return r.json();
}

async function getPerpSymbols(){
  // get 1) exchangeInfo for perps, 2) ticker24hr to score volatility
  const [ei, tick] = await Promise.all([
    fetchJSON(`https://api.binance.com/api/v3/exchangeInfo`),
    fetchJSON(`${BASE}/ticker/24hr`)
  ]);
  const perpSet = new Set((ei.symbols || [])
    .filter(s=>s.contractType==='PERPETUAL' && s.symbol.endsWith('USDT'))
    .map(s=>s.symbol));
  // filter tickers to perpetual USDT and exclude top caps, then sort by abs(priceChangePercent)*quoteVolume
  const filtered = (tick || []).filter(t => perpSet.has(t.symbol) && t.symbol.endsWith('USDT') && !EXCLUDE_TOP.has(t.symbol))
    .map(t => ({symbol: t.symbol, score: Math.abs(Number(t.priceChangePercent || 0)) * Number(t.quoteVolume || 0)}))
    .sort((a,b) => b.score - a.score)
    .slice(0, MAX_SYMBOLS)
    .map(x => x.symbol);
  return filtered;
}

async function fetchKlines(symbol, limit=30){
  const url = `${BASE}/klines?symbol=${encodeURIComponent(symbol)}&interval=1h&limit=${limit}`;
  return fetchJSON(url);
}

/* BOLLINGER helpers */
function sma(arr){
  if(!arr || arr.length===0) return NaN;
  return arr.reduce((a,b)=>a+b,0)/arr.length;
}
function std(arr, mean){
  if(!arr || arr.length===0) return NaN;
  const m = typeof mean === 'number' ? mean : sma(arr);
  const v = arr.reduce((s,x)=>s + Math.pow(x - m, 2), 0) / arr.length;
  return Math.sqrt(v);
}

/* Pattern checks */
function checkPatterns(k) {
  // k: array of klines oldest->newest
  // returns object {pass:bool, ratio:number, note:string}
  if(!k || k.length < 21) return {pass:false};

  const closes = k.map(r => Number(r[4]));
  const midsArr = closes.slice(-20);
  const mid = sma(midsArr);
  const sd = std(midsArr, mid);
  const upper = mid + 2*sd;
  const lower = mid - 2*sd;

  const last = k[k.length - 1];
  const prev = k[k.length - 2];

  const o = Number(last[1]), h = Number(last[2]), l = Number(last[3]), c = Number(last[4]), v = Number(last[5]);
  const po = Number(prev[1]), pc = Number(prev[4]), pv = Number(prev[5]);

  // Condition 1
  if(!(v > pv * 1.5)) return {pass:false};

  // pattern 2a
  if(h > upper && c < upper && c > mid){
    // ratio = (current High - current upper bb) / (current upper bb - current close)
    const denom = (upper - c);
    const ratio = denom === 0 ? NaN : (h - upper) / denom;
    return {pass:true, ratio, pattern:'2a', mid, upper, lower, prevColor: candleColor(po,pc), currColor: candleColor(o,c), o,h,l,c,v,po,pc,pv};
  }
  // 2b
  if(h > mid && c < mid && c > lower){
    const denom = (mid - c);
    const ratio = denom === 0 ? NaN : (h - mid) / denom;
    return {pass:true, ratio, pattern:'2b', mid, upper, lower, prevColor: candleColor(po,pc), currColor: candleColor(o,c), o,h,l,c,v,po,pc,pv};
  }
  // 2c
  if(l < lower && c > lower && c < mid){
    const denom = (lower - l);
    const ratio = denom === 0 ? NaN : (c - lower) / denom;
    return {pass:true, ratio, pattern:'2c', mid, upper, lower, prevColor: candleColor(po,pc), currColor: candleColor(o,c), o,h,l,c,v,po,pc,pv};
  }
  // 2d
  if(l < mid && c > mid && c < upper){
    const denom = (mid - l);
    const ratio = denom === 0 ? NaN : (c - mid) / denom;
    return {pass:true, ratio, pattern:'2d', mid, upper, lower, prevColor: candleColor(po,pc), currColor: candleColor(o,c), o,h,l,c,v,po,pc,pv};
  }

  return {pass:false};
}

/* RENDER helpers */
function appendRowLive(obj){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td class="symbol">${obj.symbol}</td>
    <td class="${obj.closePct>=0? 'green':'red'}">${round(obj.closePct)}%</td>
    <td>${round(obj.volPct)}%</td>
    <td>${obj.same}</td>
    <td>${isNaN(obj.ratio) ? 'â€”' : Number(obj.ratio).toFixed(4)}</td>
  `;
  tbody.appendChild(tr);
}

/* SORTING */
function parseCellValue(text){
  if(!text) return NaN;
  // remove % and commas
  const cleaned = text.replace(/[%\+,]/g,'').trim();
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : text.toLowerCase();
}
function sortTable(colIndex){
  const ths = resultsTable.tHead.rows[0].cells;
  const key = 'sort-' + colIndex;
  const tbodyEl = resultsTable.tBodies[0];
  const rows = Array.from(tbodyEl.rows);
  const asc = !resultsTable.dataset[key] || resultsTable.dataset[key] === 'desc';
  rows.sort((a,b)=>{
    const aVal = parseCellValue(a.cells[colIndex].innerText);
    const bVal = parseCellValue(b.cells[colIndex].innerText);
    if(typeof aVal === 'number' && typeof bVal === 'number') return asc ? aVal - bVal : bVal - aVal;
    return asc ? String(aVal).localeCompare(String(bVal)) : String(bVal).localeCompare(String(aVal));
  });
  rows.forEach(r => tbodyEl.appendChild(r));
  resultsTable.dataset[key] = asc ? 'asc' : 'desc';
}
Array.from(resultsTable.tHead.rows[0].cells).forEach((th, idx) => {
  th.addEventListener('click', ()=> sortTable(idx));
});

/* MAIN SCAN FUNCTION */
async function runScan(){
  try{
    refreshBtn.disabled = true;
    tbody.innerHTML = '<tr><td colspan="5" class="placeholder">Preparing scan...</td></tr>';
    statusEl.textContent = 'Fetching symbols...';
    fill.style.width = '0%';

    const symbols = await getPerpSymbols();
    statusEl.textContent = `Scanning 0 / ${symbols.length}`;
    tbody.innerHTML = '';
    let processed = 0;
    const matches = [];

    for(let i=0;i<symbols.length;i+=BATCH_SIZE){
      const batch = symbols.slice(i, i+BATCH_SIZE);

      // fetch klines in parallel for batch
      const kPromises = batch.map(s => fetchKlines(s, 30)
        .then(k => ({symbol:s, kl:k}))
        .catch(e => ({symbol:s, kl:null})));

      const kResults = await Promise.all(kPromises);

      // evaluate each
      for(const res of kResults){
        processed++;
        const pct = Math.round((processed / symbols.length) * 100);
        fill.style.width = pct + '%';
        statusEl.textContent = `Scanning ${processed} / ${symbols.length}: ${res.symbol}`;

        if(!res.kl || res.kl.length < 21) continue;
        const info = checkPatterns(res.kl);
        if(info.pass){
          // compute close% and vol%
          const last = res.kl[res.kl.length-1];
          const prev = res.kl[res.kl.length-2];
          const o = Number(last[1]), c = Number(last[4]), v = Number(last[5]);
          const po = Number(prev[1]), pc = Number(prev[4]), pv = Number(prev[5]);
          const closePct = pct(c, o);
          const volPct = pct(v, pv);
          const same = (info.currColor === info.prevColor) ? 'Yes' : 'No';
          const obj = {
            symbol: res.symbol,
            closePct,
            volPct,
            same,
            ratio: info.ratio
          };
          matches.push(obj);
          appendRowLive(obj);
        }
      }

      // polite short pause (avoid hitting rate limits too hard)
      await sleep(150);
    }

    statusEl.textContent = `Scan complete â€” ${matches.length} matches.`;
    fill.style.width = '100%';
    refreshBtn.disabled = false;
  } catch(err){
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
    refreshBtn.disabled = false;
  }
}

/* Wiring */
refreshBtn.addEventListener('click', ()=> {
  // clear table
  tbody.innerHTML = '<tr><td colspan="5" class="placeholder">Starting scan...</td></tr>';
  runScan();
});

// auto-run when page loads if you want (comment out if not)
window.addEventListener('load', ()=> {
  // runScan();
});
</script>
</body>
</html>



