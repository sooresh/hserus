<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hserus</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    h1 {
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }
    th {
      background-color: #333;
      color: white;
    }
    .green {
      background-color: #c8f7c5;
    }
    .red {
      background-color: #f7c5c5;
    }
    select {
      padding: 8px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Hserus</h1>
  <label for="filter">Sort by:</label>
  <select id="filter" onchange="renderTable()">
    <option value="rsi">RSI</option>
    <option value="macdDiff">MACD Diff</option>
    <option value="symbol">Name</option>
  </select>
  <table id="resultsTable">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>RSI(6)</th>
        <th>MACD Diff</th>
        <th>Signal</th>
        <th>MACD Crossover (Last 4 Candles)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <script>
    const topExcluded = ['BTC','ETH','SOL','BNB','XRP','ADA','DOGE','TON','AVAX','DOT','TRX','SHIB','LINK','NEAR','MATIC','UNI','LTC','ICP','LEO','BCH'];
    let allSymbols = [];
    let finalData = [];

    async function fetchSymbols() {
      const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
      const data = await res.json();
      allSymbols = data.symbols.filter(s => s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && !topExcluded.includes(s.baseAsset));
    }

    async function fetch24hrStats() {
      const res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
      const stats = await res.json();
      const symbolChanges = stats.filter(s => allSymbols.find(a => a.symbol === s.symbol));
      return symbolChanges.sort((a, b) => Math.abs(b.priceChangePercent) - Math.abs(a.priceChangePercent)).slice(0, 200);
    }

    function calculateMACD(values, fast = 12, slow = 26, signal = 9) {
      const ema = (data, length) => {
        const k = 2 / (length + 1);
        let emaArray = [data[0]];
        for (let i = 1; i < data.length; i++) {
          emaArray.push(data[i] * k + emaArray[i - 1] * (1 - k));
        }
        return emaArray;
      };
      const emaFast = ema(values, fast);
      const emaSlow = ema(values, slow);
      const macdLine = emaFast.map((val, i) => val - emaSlow[i]);
      const signalLine = ema(macdLine.slice(slow), signal);
      const macdHist = macdLine.slice(slow + signal - 1).map((m, i) => m - signalLine[i]);
      return { macdLine: macdLine.slice(-5), signalLine: signalLine.slice(-5), macdHist };
    }

    function checkMACDCrossover(macd, signal) {
      for (let i = 1; i < macd.length; i++) {
        if ((macd[i - 1] < signal[i - 1] && macd[i] > signal[i]) || (macd[i - 1] > signal[i - 1] && macd[i] < signal[i])) {
          return true;
        }
      }
      return false;
    }

    async function fetchKlines(symbol) {
      const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=100`);
      const data = await res.json();
      return data;
    }

    function calculateRSI(closes, period = 6) {
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    async function processSymbol(symbol) {
      const candles = await fetchKlines(symbol);
      const volumes = candles.map(c => parseFloat(c[5]));
      const closes = candles.map(c => parseFloat(c[4]));
      const open = parseFloat(candles.at(-1)[1]);
      const close = parseFloat(candles.at(-1)[4]);
      const volume = parseFloat(candles.at(-1)[5]);
      const maxVol3 = Math.max(...volumes.slice(-4, -1));
      const isVolumeBreakout = volume > maxVol3;
      const isGreen = close > open;
      const rsi = calculateRSI(closes);
      const macdData = calculateMACD(closes);
      const macdLine = macdData.macdLine.at(-1);
      const signalLine = macdData.signalLine.at(-1);
      const macdDiff = macdLine - signalLine;
      const crossover = checkMACDCrossover(macdData.macdLine, macdData.signalLine);

      if (isVolumeBreakout) {
        if ((isGreen && rsi > 65) || (!isGreen && rsi < 35)) {
          finalData.push({ symbol, rsi: rsi.toFixed(2), macdDiff: macdDiff.toFixed(4), signal: isGreen ? 'Buy' : 'Sell', crossover });
        }
      }
    }

    async function main() {
      await fetchSymbols();
      const topVolatile = await fetch24hrStats();
      for (const s of topVolatile) {
        await processSymbol(s.symbol);
      }
      renderTable();
    }

    function renderTable() {
      const filter = document.getElementById('filter').value;
      const sorted = [...finalData].sort((a, b) => {
        if (filter === 'symbol') return a.symbol.localeCompare(b.symbol);
        else return b[filter] - a[filter];
      });
      const tbody = document.querySelector('#resultsTable tbody');
      tbody.innerHTML = '';
      sorted.forEach(row => {
        const tr = document.createElement('tr');
        tr.className = row.signal === 'Buy' ? 'green' : 'red';
        tr.innerHTML = `
          <td>${row.symbol}</td>
          <td>${row.rsi}</td>
          <td>${row.macdDiff}</td>
          <td>${row.signal}</td>
          <td>${row.crossover ? 'Yes' : 'No'}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    main();
  </script>
</body>
</html>

