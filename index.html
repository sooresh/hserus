<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crypto Signal Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
      color: #333;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .filters {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
      gap: 10px;
    }
    .crypto {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      margin-bottom: 10px;
      padding: 10px 15px;
    }
    .green { border-left: 5px solid green; }
    .red { border-left: 5px solid red; }
    select {
      padding: 5px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>ðŸ“Š Crypto Signal Scanner (1H)</h1>
  <div class="filters">
    <label>
      Sort by:
      <select id="sort">
        <option value="rsi">RSI</option>
        <option value="macd">MACD Diff</option>
        <option value="name">Name</option>
      </select>
    </label>
  </div>
  <div id="output">Loading...</div>

  <script>
    const top20 = ['BTCUSDT','ETHUSDT','SOLUSDT','BNBUSDT','XRPUSDT','ADAUSDT','DOGEUSDT','TONUSDT','AVAXUSDT','DOTUSDT','SHIBUSDT','TRXUSDT','LINKUSDT','NEARUSDT','MATICUSDT','LTCUSDT','UNIUSDT','BCHUSDT','XLMUSDT','ICPUSDT'];
    const output = document.getElementById('output');
    let results = [];

    async function fetchFuturesSymbols() {
      const res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
      const data = await res.json();
      return data.filter(s => s.symbol.endsWith('USDT') && !top20.includes(s.symbol))
        .sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent))
        .slice(0, 200)
        .map(s => s.symbol);
    }

    async function fetchKlines(symbol, interval = '1h', limit = 50) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const res = await fetch(url);
      const data = await res.json();
      return data.map(c => ({
        open: parseFloat(c[1]),
        close: parseFloat(c[4]),
        volume: parseFloat(c[5])
      }));
    }

    function calculateRSI(closes, period = 6) {
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        let diff = closes[i] - closes[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      if (losses === 0) return 100;
      const rs = gains / losses;
      return 100 - (100 / (1 + rs));
    }

    function calculateMACD(closes, short = 12, long = 26, signal = 9) {
      const ema = (arr, period) => {
        const k = 2 / (period + 1);
        let emaArr = [arr.slice(0, period).reduce((a, b) => a + b) / period];
        for (let i = period; i < arr.length; i++) {
          const emaVal = arr[i] * k + emaArr[emaArr.length - 1] * (1 - k);
          emaArr.push(emaVal);
        }
        return emaArr;
      };
      const emaShort = ema(closes, short);
      const emaLong = ema(closes, long);
      const macdLine = emaShort.slice(-emaLong.length).map((v, i) => v - emaLong[i]);
      const signalLine = ema(macdLine, signal);
      const macdHist = macdLine.slice(-signalLine.length).map((v, i) => v - signalLine[i]);
      return {
        macd: macdLine.at(-1),
        signal: signalLine.at(-1),
        diff: macdLine.at(-1) - signalLine.at(-1)
      };
    }

    async function scan() {
      output.innerHTML = "Scanning...";
      const symbols = await fetchFuturesSymbols();
      results = [];

      for (const symbol of symbols) {
        try {
          const candles = await fetchKlines(symbol);
          const closes = candles.map(c => c.close);
          const current = candles.at(-1);
          const prev3Vol = candles.slice(-4, -1).map(c => c.volume);
          const maxVol = Math.max(...prev3Vol);

          if (current.volume <= maxVol) continue;

          const rsi = calculateRSI(closes.slice(-7));
          const isRed = current.close < current.open;
          const isGreen = current.close > current.open;

          if (!(isRed && rsi < 35) && !(isGreen && rsi > 65)) continue;

          const { macd, signal, diff } = calculateMACD(closes);

          results.push({ symbol, rsi: rsi.toFixed(2), macd: macd.toFixed(4), signal: signal.toFixed(4), diff: diff.toFixed(4), green: isGreen });
        } catch (e) {
          console.error(symbol, e);
        }
      }

      render();
    }

    function render() {
      const sortBy = document.getElementById('sort').value;
      output.innerHTML = "";
      const sorted = [...results];
      sorted.sort((a, b) => {
        if (sortBy === 'rsi') return b.rsi - a.rsi;
        if (sortBy === 'macd') return b.diff - a.diff;
        if (sortBy === 'name') return a.symbol.localeCompare(b.symbol);
      });

      sorted.forEach(item => {
        const div = document.createElement('div');
        div.className = `crypto ${item.green ? 'green' : 'red'}`;
        div.innerHTML = `<strong>${item.symbol}</strong><br>
          RSI(6): ${item.rsi}<br>
          MACD: ${item.macd}, Signal: ${item.signal}, Diff: ${item.diff}`;
        output.appendChild(div);
      });

      if (sorted.length === 0) output.innerHTML = "No matching coins found.";
    }

    document.getElementById('sort').addEventListener('change', render);

    scan();
  </script>
</body>
</html>
