<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>hserus</title>
<style>
  body { font-family: Arial, Helvetica, sans-serif; margin:18px; background:#f7f9fc; color:#111; }
  h1 { font-size:20px; margin-bottom:6px; }
  .controls { display:flex; gap:10px; align-items:center; margin-bottom:10px; }
  button { padding:8px 12px; border-radius:6px; border:1px solid #888; background:#fff; cursor:pointer; }
  button:active { transform:translateY(1px); }
  #progress { font-size:13px; color:#333; }
  table { border-collapse:collapse; width:100%; background:#fff; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
  th, td { padding:10px 8px; text-align:left; border-bottom:1px solid #eee; font-size:13px; }
  th { cursor:pointer; user-select:none; position:relative; }
  th .sort-ind { font-size:11px; margin-left:6px; color:#666; }
  tr.match { background: #e9fff2; }
  .small { font-size:12px; color:#555; }
</style>
</head>
<body>
  <h1>hserus</h1>
  <div class="controls">
    <button id="refreshBtn">Refresh</button>
    <div id="progress" class="small">Idle</div>
    <div style="flex:1"></div>
    <div class="small">Scanned: <span id="scannedCount">0</span>/<span id="totalCount">0</span></div>
  </div>

  <table id="resultsTable">
    <thead>
      <tr>
        <th data-col="symbol">Symbol <span class="sort-ind"></span></th>
        <th data-col="closePct">Close % <span class="sort-ind"></span></th>
        <th data-col="volPct">Vol % <span class="sort-ind"></span></th>
        <th data-col="netPct">Net Δ% <span class="sort-ind"></span></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
const EXCLUDE_TOP_25 = [
  "BTCUSDT","ETHUSDT","BNBUSDT","XRPUSDT","ADAUSDT","SOLUSDT","DOTUSDT","DOGEUSDT","TRXUSDT",
  "LTCUSDT","LINKUSDT","BCHUSDT","MATICUSDT","UNIUSDT","AVAXUSDT","SHIBUSDT","NEARUSDT",
  "ALGOUSDT","ATOMUSDT","XMRUSDT","APEUSDT","SANDUSDT","FILUSDT","VETUSDT","ICPUSDT"
];

const MAX_SYMBOLS = 200;
const TIMEFRAME = "1h";

const resultsTableBody = document.querySelector("#resultsTable tbody");
const progressEl = document.getElementById("progress");
const scannedCountEl = document.getElementById("scannedCount");
const totalCountEl = document.getElementById("totalCount");
const refreshBtn = document.getElementById("refreshBtn");

let currentSort = { col: "symbol", dir: 1 };
refreshBtn.addEventListener("click", startScan);

document.querySelectorAll("th[data-col]").forEach(th => {
  th.addEventListener("click", () => {
    const col = th.dataset.col;
    if (currentSort.col === col) currentSort.dir *= -1;
    else { currentSort.col = col; currentSort.dir = 1; }
    renderTable(currentMatches);
  });
});

let currentMatches = [];

function fmtNum(n, decimals=2) {
  if (isNaN(n) || n === null) return "-";
  return Number(n).toFixed(decimals);
}
function fmtSignedPct(v){
  if (!isFinite(v)) return "∞";
  const s = (v >= 0 ? "+" : "") + fmtNum(v, 2) + "%";
  return s;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function fetchWithTimeout(url, opts={}, ms=12000){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), ms);
  try {
    opts.signal = controller.signal;
    const res = await fetch(url, opts);
    clearTimeout(id);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return res;
  } catch (e) {
    clearTimeout(id);
    throw e;
  }
}

async function startScan(){
  currentMatches = [];
  resultsTableBody.innerHTML = "";
  progressEl.textContent = "Getting symbol list...";
  scannedCountEl.textContent = "0";
  totalCountEl.textContent = "0";

  try {
    const tickersResp = await fetchWithTimeout("https://fapi.binance.com/fapi/v1/ticker/24hr");
    const tickers = await tickersResp.json();

    let usdtTickers = tickers.filter(t => t.symbol && t.symbol.endsWith("USDT"));
    usdtTickers = usdtTickers.filter(t => !EXCLUDE_TOP_25.includes(t.symbol));
    usdtTickers.forEach(t => { t.abs24h = Math.abs(Number(t.priceChangePercent || 0)); });
    usdtTickers.sort((a,b) => b.abs24h - a.abs24h);
    const selected = usdtTickers.slice(0, MAX_SYMBOLS);
    totalCountEl.textContent = String(selected.length);

    let idx = 0;
    for (const t of selected){
      idx++;
      scannedCountEl.textContent = String(idx);
      progressEl.textContent = `Scanning ${idx} / ${selected.length}: ${t.symbol}`;
      try {
        await processSymbol(t.symbol);
      } catch (e) {
        console.warn("Failed symbol", t.symbol, e);
      }
      await sleep(200);
    }
    progressEl.textContent = `Done — found ${currentMatches.length} matches`;
    renderTable(currentMatches);

  } catch (err) {
    console.error(err);
    progressEl.textContent = "Error: " + (err.message || err);
  }
}

async function processSymbol(symbol){
  // 1) Last 3 hourly klines
  const kURL = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${TIMEFRAME}&limit=3`;
  const kres = await fetchWithTimeout(kURL);
  const klines = await kres.json();
  if (!Array.isArray(klines) || klines.length < 3) return;

  const prev1 = klines[1];
  const curr = klines[2];

  const currOpen = Number(curr[1]), currClose = Number(curr[4]), currVol = Number(curr[5]);
  const prev1Vol = Number(prev1[5]), prev2Vol = Number(klines[0][5]);
  const candleChangePct = (currClose - currOpen) / currOpen * 100;
  if (!(Math.abs(candleChangePct) > 1)) return;
  if (!(currVol > prev1Vol && currVol > prev2Vol)) return;

  // 2) Ratios (prev & curr hour)
  const ratioURL = `https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=1h&limit=2`;
  const rres = await fetchWithTimeout(ratioURL);
  const ratios = await rres.json();
  if (!Array.isArray(ratios) || ratios.length < 2) return;
  ratios.sort((a,b) => a.timestamp - b.timestamp);
  const prevRatio = ratios[0], currRatio = ratios[1];
  const pL = Number(prevRatio.longAccount), pS = Number(prevRatio.shortAccount);
  const cL = Number(currRatio.longAccount), cS = Number(currRatio.shortAccount);

  // 3) Open Interest history (prev & curr hour)
  const oiURL = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=1h&limit=2`;
  const oires = await fetchWithTimeout(oiURL);
  const oiHist = await oires.json();
  if (!Array.isArray(oiHist) || oiHist.length < 2) return;
  oiHist.sort((a,b) => a.timestamp - b.timestamp);
  const prevOI = Number(oiHist[0].sumOpenInterest), currOI = Number(oiHist[1].sumOpenInterest);

  // 4) Compute longs/shorts/net
  const prevLongs = prevOI * (pL / (pL + pS));
  const prevShorts = prevOI - prevLongs;
  const currLongs = currOI * (cL / (cL + cS));
  const currShorts = currOI - currLongs;

  const isRed = currClose < currOpen;
  const isGreen = currClose > currOpen;
  let netChangePct = 0;
  if (isRed) {
    if (!(currLongs > prevLongs)) return;
    netChangePct = prevLongs === 0 ? 0 : ((currLongs - prevLongs)/Math.abs(prevLongs))*100;
  } else if (isGreen) {
    if (!(currShorts > prevShorts)) return;
    netChangePct = prevShorts === 0 ? 0 : ((currShorts - prevShorts)/Math.abs(prevShorts))*100;
  } else return;

  const closePct = candleChangePct;
  const volPct = ((currVol - prev1Vol) / prev1Vol) * 100;

  currentMatches.push({ symbol, closePct, volPct, netPct: netChangePct });
  renderTable(currentMatches);
}

function renderTable(rows){
  const sorted = rows.slice();
  const col = currentSort.col, dir = currentSort.dir;
  sorted.sort((a,b)=>{
    let va = a[col], vb = b[col];
    if (col === "symbol") return dir * (va.localeCompare(vb));
    else return dir * (Number(va||0) - Number(vb||0));
  });

  resultsTableBody.innerHTML = "";
  for (const r of sorted){
    const tr = document.createElement("tr");
    tr.className = "match";
    tr.innerHTML = `
      <td>${r.symbol}</td>
      <td>${fmtSignedPct(r.closePct)}</td>
      <td>${fmtSignedPct(r.volPct)}</td>
      <td>${fmtSignedPct(r.netPct)}</td>
    `;
    resultsTableBody.appendChild(tr);
  }
  document.querySelectorAll("th[data-col]").forEach(th=>{
    const sc = th.dataset.col, ind = th.querySelector(".sort-ind");
    if (sc === currentSort.col) ind.textContent = currentSort.dir === 1 ? "▲" : "▼";
    else ind.textContent = "";
  });
}
</script>
</body>
</html>
